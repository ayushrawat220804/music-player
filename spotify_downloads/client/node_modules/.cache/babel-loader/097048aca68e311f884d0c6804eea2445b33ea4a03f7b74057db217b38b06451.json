{"ast":null,"code":"/**\r\n * Audio utility functions for the enhanced audio player\r\n */\n\n/**\r\n * Extracts the dominant color from an image URL\r\n * @param imageUrl URL of the image to analyze\r\n * @returns Promise resolving to a hex color string\r\n */\nexport const extractDominantColor = async imageUrl => {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = new Image();\n      img.crossOrigin = 'Anonymous';\n      img.onload = () => {\n        // Create a canvas to draw the image\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n          reject(new Error('Could not get canvas context'));\n          return;\n        }\n\n        // Set canvas size to a small sample (for performance)\n        canvas.width = 50;\n        canvas.height = 50;\n\n        // Draw image to canvas\n        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n        // Get image data\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const data = imageData.data;\n\n        // Calculate average color\n        let r = 0,\n          g = 0,\n          b = 0;\n        let pixelCount = 0;\n\n        // Sample pixels (every 4th pixel for performance)\n        for (let i = 0; i < data.length; i += 16) {\n          const red = data[i];\n          const green = data[i + 1];\n          const blue = data[i + 2];\n          const alpha = data[i + 3];\n\n          // Skip transparent pixels\n          if (alpha < 128) continue;\n          r += red;\n          g += green;\n          b += blue;\n          pixelCount++;\n        }\n\n        // Calculate average\n        if (pixelCount > 0) {\n          r = Math.floor(r / pixelCount);\n          g = Math.floor(g / pixelCount);\n          b = Math.floor(b / pixelCount);\n\n          // Convert to hex\n          const hex = rgbToHex(r, g, b);\n          resolve(hex);\n        } else {\n          // Default color if no valid pixels\n          resolve('#121212');\n        }\n      };\n      img.onerror = () => {\n        reject(new Error('Failed to load image'));\n      };\n      img.src = imageUrl;\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n\n/**\r\n * Converts RGB values to a hex color string\r\n */\nconst rgbToHex = (r, g, b) => {\n  return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;\n};\n\n/**\r\n * Converts a single color component to hex\r\n */\nconst componentToHex = c => {\n  const hex = c.toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n};\n\n/**\r\n * Formats time in seconds to MM:SS format\r\n * @param seconds Time in seconds\r\n * @returns Formatted time string\r\n */\nexport const formatTime = seconds => {\n  if (isNaN(seconds) || seconds < 0) return '0:00';\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = Math.floor(seconds % 60);\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n};\n\n/**\r\n * Calculates the frequency data from an analyzer node\r\n * @param analyser Web Audio API analyzer node\r\n * @returns Object with bass, mid, and treble values\r\n */\nexport const calculateFrequencyData = analyser => {\n  if (!analyser) {\n    return {\n      bass: 0,\n      mid: 0,\n      treble: 0,\n      average: 0\n    };\n  }\n  const bufferLength = analyser.frequencyBinCount;\n  const dataArray = new Uint8Array(bufferLength);\n  analyser.getByteFrequencyData(dataArray);\n\n  // Calculate frequency ranges (approximate)\n  // Bass: 20-250Hz, Mid: 250-2000Hz, Treble: 2000-20000Hz\n  // The exact bin indices depend on the FFT size and sample rate\n\n  // Assuming standard 44.1kHz sample rate and fftSize of 2048\n  // Each bin represents ~21.5Hz (44100/2048)\n\n  const bassRange = {\n    start: 1,\n    end: 12\n  }; // ~20-250Hz\n  const midRange = {\n    start: 12,\n    end: 93\n  }; // ~250-2000Hz\n  const trebleRange = {\n    start: 93,\n    end: bufferLength\n  }; // ~2000-20000Hz\n\n  let bassSum = 0;\n  let midSum = 0;\n  let trebleSum = 0;\n  let totalSum = 0;\n\n  // Calculate sums for each range\n  for (let i = 0; i < bufferLength; i++) {\n    const value = dataArray[i];\n    totalSum += value;\n    if (i >= bassRange.start && i < bassRange.end) {\n      bassSum += value;\n    } else if (i >= midRange.start && i < midRange.end) {\n      midSum += value;\n    } else if (i >= trebleRange.start && i < trebleRange.end) {\n      trebleSum += value;\n    }\n  }\n\n  // Normalize values between 0 and 1\n  const bass = bassSum / ((bassRange.end - bassRange.start) * 255);\n  const mid = midSum / ((midRange.end - midRange.start) * 255);\n  const treble = trebleSum / ((trebleRange.end - trebleRange.start) * 255);\n  const average = totalSum / (bufferLength * 255);\n  return {\n    bass,\n    mid,\n    treble,\n    average\n  };\n};\n\n/**\r\n * Sanitizes a URL for audio playback\r\n * @param url The URL to sanitize\r\n * @returns Sanitized URL\r\n */\nexport const sanitizeAudioUrl = url => {\n  // Handle file:// URLs for local files\n  if (url.startsWith('file://')) {\n    // Remove file:// prefix and decode URI components\n    return decodeURIComponent(url.replace(/^file:\\/\\//, ''));\n  }\n\n  // Handle Windows paths\n  if (/^[A-Z]:\\\\/i.test(url)) {\n    return url;\n  }\n\n  // Handle regular URLs\n  return url;\n};\n\n/**\r\n * Generates a waveform visualization data array from audio buffer\r\n * @param audioBuffer The audio buffer to analyze\r\n * @param numPoints Number of data points to generate\r\n * @returns Array of normalized amplitude values\r\n */\nexport const generateWaveformData = (audioBuffer, numPoints) => {\n  const channelData = audioBuffer.getChannelData(0); // Use first channel\n  const blockSize = Math.floor(channelData.length / numPoints);\n  const waveformData = [];\n  for (let i = 0; i < numPoints; i++) {\n    const startSample = blockSize * i;\n    let sum = 0;\n\n    // Calculate average amplitude for this block\n    for (let j = 0; j < blockSize; j++) {\n      sum += Math.abs(channelData[startSample + j] || 0);\n    }\n    const average = sum / blockSize;\n    waveformData.push(average);\n  }\n  return waveformData;\n};\n\n/**\r\n * Smoothly interpolates between two values\r\n * @param current Current value\r\n * @param target Target value\r\n * @param factor Smoothing factor (0-1)\r\n * @returns Interpolated value\r\n */\nexport const smoothValue = (current, target, factor = 0.3) => {\n  return current + (target - current) * factor;\n};\nexport default {\n  extractDominantColor,\n  formatTime,\n  calculateFrequencyData,\n  sanitizeAudioUrl,\n  generateWaveformData,\n  smoothValue\n};","map":{"version":3,"names":["extractDominantColor","imageUrl","Promise","resolve","reject","img","Image","crossOrigin","onload","canvas","document","createElement","ctx","getContext","Error","width","height","drawImage","imageData","getImageData","data","r","g","b","pixelCount","i","length","red","green","blue","alpha","Math","floor","hex","rgbToHex","onerror","src","error","componentToHex","c","toString","formatTime","seconds","isNaN","minutes","remainingSeconds","padStart","calculateFrequencyData","analyser","bass","mid","treble","average","bufferLength","frequencyBinCount","dataArray","Uint8Array","getByteFrequencyData","bassRange","start","end","midRange","trebleRange","bassSum","midSum","trebleSum","totalSum","value","sanitizeAudioUrl","url","startsWith","decodeURIComponent","replace","test","generateWaveformData","audioBuffer","numPoints","channelData","getChannelData","blockSize","waveformData","startSample","sum","j","abs","push","smoothValue","current","target","factor"],"sources":["C:/Users/rohit/spotify/spotify_downloads/client/src/components/audio-player/utils/audioUtils.ts"],"sourcesContent":["/**\r\n * Audio utility functions for the enhanced audio player\r\n */\r\n\r\n/**\r\n * Extracts the dominant color from an image URL\r\n * @param imageUrl URL of the image to analyze\r\n * @returns Promise resolving to a hex color string\r\n */\r\nexport const extractDominantColor = async (imageUrl: string): Promise<string> => {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      const img = new Image();\r\n      img.crossOrigin = 'Anonymous';\r\n      \r\n      img.onload = () => {\r\n        // Create a canvas to draw the image\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        if (!ctx) {\r\n          reject(new Error('Could not get canvas context'));\r\n          return;\r\n        }\r\n        \r\n        // Set canvas size to a small sample (for performance)\r\n        canvas.width = 50;\r\n        canvas.height = 50;\r\n        \r\n        // Draw image to canvas\r\n        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n        \r\n        // Get image data\r\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n        const data = imageData.data;\r\n        \r\n        // Calculate average color\r\n        let r = 0, g = 0, b = 0;\r\n        let pixelCount = 0;\r\n        \r\n        // Sample pixels (every 4th pixel for performance)\r\n        for (let i = 0; i < data.length; i += 16) {\r\n          const red = data[i];\r\n          const green = data[i + 1];\r\n          const blue = data[i + 2];\r\n          const alpha = data[i + 3];\r\n          \r\n          // Skip transparent pixels\r\n          if (alpha < 128) continue;\r\n          \r\n          r += red;\r\n          g += green;\r\n          b += blue;\r\n          pixelCount++;\r\n        }\r\n        \r\n        // Calculate average\r\n        if (pixelCount > 0) {\r\n          r = Math.floor(r / pixelCount);\r\n          g = Math.floor(g / pixelCount);\r\n          b = Math.floor(b / pixelCount);\r\n          \r\n          // Convert to hex\r\n          const hex = rgbToHex(r, g, b);\r\n          resolve(hex);\r\n        } else {\r\n          // Default color if no valid pixels\r\n          resolve('#121212');\r\n        }\r\n      };\r\n      \r\n      img.onerror = () => {\r\n        reject(new Error('Failed to load image'));\r\n      };\r\n      \r\n      img.src = imageUrl;\r\n    } catch (error) {\r\n      reject(error);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Converts RGB values to a hex color string\r\n */\r\nconst rgbToHex = (r: number, g: number, b: number): string => {\r\n  return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;\r\n};\r\n\r\n/**\r\n * Converts a single color component to hex\r\n */\r\nconst componentToHex = (c: number): string => {\r\n  const hex = c.toString(16);\r\n  return hex.length === 1 ? '0' + hex : hex;\r\n};\r\n\r\n/**\r\n * Formats time in seconds to MM:SS format\r\n * @param seconds Time in seconds\r\n * @returns Formatted time string\r\n */\r\nexport const formatTime = (seconds: number): string => {\r\n  if (isNaN(seconds) || seconds < 0) return '0:00';\r\n  \r\n  const minutes = Math.floor(seconds / 60);\r\n  const remainingSeconds = Math.floor(seconds % 60);\r\n  \r\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\r\n};\r\n\r\n/**\r\n * Calculates the frequency data from an analyzer node\r\n * @param analyser Web Audio API analyzer node\r\n * @returns Object with bass, mid, and treble values\r\n */\r\nexport const calculateFrequencyData = (analyser: AnalyserNode | null): { \r\n  bass: number; \r\n  mid: number; \r\n  treble: number;\r\n  average: number;\r\n} => {\r\n  if (!analyser) {\r\n    return { bass: 0, mid: 0, treble: 0, average: 0 };\r\n  }\r\n  \r\n  const bufferLength = analyser.frequencyBinCount;\r\n  const dataArray = new Uint8Array(bufferLength);\r\n  analyser.getByteFrequencyData(dataArray);\r\n  \r\n  // Calculate frequency ranges (approximate)\r\n  // Bass: 20-250Hz, Mid: 250-2000Hz, Treble: 2000-20000Hz\r\n  // The exact bin indices depend on the FFT size and sample rate\r\n  \r\n  // Assuming standard 44.1kHz sample rate and fftSize of 2048\r\n  // Each bin represents ~21.5Hz (44100/2048)\r\n  \r\n  const bassRange = { start: 1, end: 12 }; // ~20-250Hz\r\n  const midRange = { start: 12, end: 93 }; // ~250-2000Hz\r\n  const trebleRange = { start: 93, end: bufferLength }; // ~2000-20000Hz\r\n  \r\n  let bassSum = 0;\r\n  let midSum = 0;\r\n  let trebleSum = 0;\r\n  let totalSum = 0;\r\n  \r\n  // Calculate sums for each range\r\n  for (let i = 0; i < bufferLength; i++) {\r\n    const value = dataArray[i];\r\n    totalSum += value;\r\n    \r\n    if (i >= bassRange.start && i < bassRange.end) {\r\n      bassSum += value;\r\n    } else if (i >= midRange.start && i < midRange.end) {\r\n      midSum += value;\r\n    } else if (i >= trebleRange.start && i < trebleRange.end) {\r\n      trebleSum += value;\r\n    }\r\n  }\r\n  \r\n  // Normalize values between 0 and 1\r\n  const bass = bassSum / ((bassRange.end - bassRange.start) * 255);\r\n  const mid = midSum / ((midRange.end - midRange.start) * 255);\r\n  const treble = trebleSum / ((trebleRange.end - trebleRange.start) * 255);\r\n  const average = totalSum / (bufferLength * 255);\r\n  \r\n  return { bass, mid, treble, average };\r\n};\r\n\r\n/**\r\n * Sanitizes a URL for audio playback\r\n * @param url The URL to sanitize\r\n * @returns Sanitized URL\r\n */\r\nexport const sanitizeAudioUrl = (url: string): string => {\r\n  // Handle file:// URLs for local files\r\n  if (url.startsWith('file://')) {\r\n    // Remove file:// prefix and decode URI components\r\n    return decodeURIComponent(url.replace(/^file:\\/\\//, ''));\r\n  }\r\n  \r\n  // Handle Windows paths\r\n  if (/^[A-Z]:\\\\/i.test(url)) {\r\n    return url;\r\n  }\r\n  \r\n  // Handle regular URLs\r\n  return url;\r\n};\r\n\r\n/**\r\n * Generates a waveform visualization data array from audio buffer\r\n * @param audioBuffer The audio buffer to analyze\r\n * @param numPoints Number of data points to generate\r\n * @returns Array of normalized amplitude values\r\n */\r\nexport const generateWaveformData = (audioBuffer: AudioBuffer, numPoints: number): number[] => {\r\n  const channelData = audioBuffer.getChannelData(0); // Use first channel\r\n  const blockSize = Math.floor(channelData.length / numPoints);\r\n  const waveformData: number[] = [];\r\n  \r\n  for (let i = 0; i < numPoints; i++) {\r\n    const startSample = blockSize * i;\r\n    let sum = 0;\r\n    \r\n    // Calculate average amplitude for this block\r\n    for (let j = 0; j < blockSize; j++) {\r\n      sum += Math.abs(channelData[startSample + j] || 0);\r\n    }\r\n    \r\n    const average = sum / blockSize;\r\n    waveformData.push(average);\r\n  }\r\n  \r\n  return waveformData;\r\n};\r\n\r\n/**\r\n * Smoothly interpolates between two values\r\n * @param current Current value\r\n * @param target Target value\r\n * @param factor Smoothing factor (0-1)\r\n * @returns Interpolated value\r\n */\r\nexport const smoothValue = (current: number, target: number, factor: number = 0.3): number => {\r\n  return current + (target - current) * factor;\r\n};\r\n\r\nexport default {\r\n  extractDominantColor,\r\n  formatTime,\r\n  calculateFrequencyData,\r\n  sanitizeAudioUrl,\r\n  generateWaveformData,\r\n  smoothValue\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}