{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\n\n/**\r\n * Custom hook to manage Web Audio API context and related resources\r\n */\nexport const useAudioContext = audioRef => {\n  _s();\n  const [audioContext, setAudioContext] = useState(null);\n  const [analyser, setAnalyser] = useState(null);\n  const [audioSource, setAudioSource] = useState(null);\n  const animationFrameRef = useRef(null);\n\n  /**\r\n   * Safely close an AudioContext\r\n   */\n  const safelyCloseAudioContext = useCallback(context => {\n    if (!context) return Promise.resolve();\n    try {\n      if (context.state === 'closed') {\n        console.log('Context already closed, no action needed');\n        return Promise.resolve();\n      }\n      console.log('Safely closing audio context...');\n      return context.close().catch(err => {\n        console.error('Error during safe context close:', err);\n      });\n    } catch (error) {\n      console.error('Exception during safe context close:', error);\n      return Promise.resolve();\n    }\n  }, []);\n\n  /**\r\n   * Reset and clean up audio context and related resources\r\n   */\n  const resetAudioContext = useCallback(() => {\n    console.log('Resetting audio context...');\n\n    // Clean up existing audio processing chain\n    if (audioSource) {\n      try {\n        audioSource.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source', e);\n      }\n      setAudioSource(null);\n    }\n    if (analyser) {\n      try {\n        analyser.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting analyser', e);\n      }\n      setAnalyser(null);\n    }\n    if (audioContext) {\n      try {\n        // Check if the AudioContext is not already closed before trying to close it\n        if (audioContext.state !== 'closed') {\n          console.log('Closing AudioContext, current state:', audioContext.state);\n          audioContext.close().catch(err => {\n            console.error('Error closing audio context:', err);\n          });\n        } else {\n          console.log('AudioContext already closed, skipping close operation');\n        }\n      } catch (e) {\n        console.error('Error with audio context:', e);\n      }\n      setAudioContext(null);\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, [audioContext, audioSource, analyser]);\n\n  /**\r\n   * Modified reset function that uses the safe close helper\r\n   */\n  const safeResetAudioContext = useCallback(() => {\n    console.log('Safely resetting audio context...');\n\n    // Clean up existing audio processing chain\n    if (audioSource) {\n      try {\n        audioSource.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source', e);\n      }\n      setAudioSource(null);\n    }\n    if (analyser) {\n      try {\n        analyser.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting analyser', e);\n      }\n      setAnalyser(null);\n    }\n\n    // Use the safe close helper\n    if (audioContext) {\n      safelyCloseAudioContext(audioContext).then(() => {\n        setAudioContext(null);\n        console.log('Audio context safely closed and reset');\n      });\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, [audioContext, audioSource, analyser, safelyCloseAudioContext]);\n\n  /**\r\n   * Create a new audio context and analyzer\r\n   */\n  const createAudioContext = useCallback(url => {\n    console.log('Creating new audio context...');\n\n    // First safely reset any existing context\n    if (audioContext || audioSource || analyser) {\n      safeResetAudioContext();\n\n      // Wait a small amount of time to ensure context is properly reset\n      // This helps prevent errors when creating a new context immediately after closing an old one\n      return new Promise(resolve => {\n        setTimeout(() => {\n          createNewContext(url).then(resolve);\n        }, 100);\n      });\n    } else {\n      return createNewContext(url);\n    }\n\n    // Helper function to create a new context\n    async function createNewContext(sourceUrl) {\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        if (!AudioContext) {\n          console.error('AudioContext not supported in this browser');\n          return false;\n        }\n        const audio = audioRef.current;\n        if (!audio) {\n          console.error('Audio element not found');\n          return false;\n        }\n\n        // Check if audio has a valid source\n        if (!audio.src || audio.src === 'about:blank') {\n          console.warn('Audio element has no source, checking URL...');\n          if (sourceUrl) {\n            console.log('Setting audio source from URL before creating context');\n            audio.src = sourceUrl;\n            audio.load();\n          } else {\n            console.error('No URL available for audio source');\n            return false;\n          }\n        }\n\n        // Create new context\n        const newAudioContext = new AudioContext();\n        console.log('New AudioContext created, state:', newAudioContext.state);\n\n        // Create new analyzer\n        const newAnalyser = newAudioContext.createAnalyser();\n        newAnalyser.fftSize = 256;\n        newAnalyser.smoothingTimeConstant = 0.7;\n\n        // Connect audio element to the analyser\n        let source;\n        try {\n          source = newAudioContext.createMediaElementSource(audio);\n        } catch (err) {\n          // Type cast the unknown error to access its properties\n          const error = err;\n\n          // Handle the case where the audio element is already connected\n          if (error !== null && error !== void 0 && error.message && error.message.includes('already connected')) {\n            console.warn('Audio element already connected, trying alternative approach...');\n\n            // First safely close any existing context\n            if (audioContext) {\n              await safelyCloseAudioContext(audioContext);\n              setAudioContext(null);\n            }\n\n            // Create a fresh audio element to work with\n            try {\n              // Temporarily disconnect the audio element\n              audio.pause();\n\n              // Create a new audio context and try again with a small delay\n              const retryContext = new AudioContext();\n              const retryAnalyser = retryContext.createAnalyser();\n              retryAnalyser.fftSize = 256;\n              retryAnalyser.smoothingTimeConstant = 0.7;\n\n              // Try with the existing audio element\n              source = retryContext.createMediaElementSource(audio);\n              source.connect(retryAnalyser);\n              retryAnalyser.connect(retryContext.destination);\n\n              // Update state with new components\n              setAudioContext(retryContext);\n              setAnalyser(retryAnalyser);\n              setAudioSource(source);\n              console.log('Successfully created audio context on retry');\n              return true;\n            } catch (retryError) {\n              console.error('Failed on retry to create audio context:', retryError);\n              return false;\n            }\n          } else {\n            console.error('Failed to create media element source:', error);\n            return false;\n          }\n        }\n        source.connect(newAnalyser);\n        newAnalyser.connect(newAudioContext.destination);\n\n        // Update state with new components\n        setAudioContext(newAudioContext);\n        setAnalyser(newAnalyser);\n        setAudioSource(source);\n\n        // Resume context if needed\n        if (newAudioContext.state === 'suspended') {\n          try {\n            await newAudioContext.resume();\n            console.log('AudioContext resumed successfully');\n          } catch (err) {\n            console.error('Failed to resume AudioContext:', err);\n          }\n        }\n        console.log('Audio context created and initialized successfully');\n        return true;\n      } catch (err) {\n        console.error('Failed to create audio context:', err);\n        return false;\n      }\n    }\n  }, [audioRef, audioContext, audioSource, analyser, safeResetAudioContext, safelyCloseAudioContext]);\n  return {\n    audioContext,\n    analyser,\n    audioSource,\n    animationFrameRef,\n    resetAudioContext,\n    safeResetAudioContext,\n    safelyCloseAudioContext,\n    createAudioContext,\n    setAudioContext,\n    setAnalyser,\n    setAudioSource\n  };\n};\n_s(useAudioContext, \"cemFwFQDafyh039gOWtTXryuSLw=\");\nexport default useAudioContext;","map":{"version":3,"names":["useState","useCallback","useRef","useAudioContext","audioRef","_s","audioContext","setAudioContext","analyser","setAnalyser","audioSource","setAudioSource","animationFrameRef","safelyCloseAudioContext","context","Promise","resolve","state","console","log","close","catch","err","error","resetAudioContext","disconnect","e","current","cancelAnimationFrame","safeResetAudioContext","then","createAudioContext","url","setTimeout","createNewContext","sourceUrl","AudioContext","window","webkitAudioContext","audio","src","warn","load","newAudioContext","newAnalyser","createAnalyser","fftSize","smoothingTimeConstant","source","createMediaElementSource","message","includes","pause","retryContext","retryAnalyser","connect","destination","retryError","resume"],"sources":["C:/Users/rohit/spotify/spotify_downloads/client/src/components/audio-player/hooks/useAudioContext.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\r\n\r\n/**\r\n * Custom hook to manage Web Audio API context and related resources\r\n */\r\nexport const useAudioContext = (audioRef: React.RefObject<HTMLAudioElement>) => {\r\n  const [audioContext, setAudioContext] = useState<AudioContext | null>(null);\r\n  const [analyser, setAnalyser] = useState<AnalyserNode | null>(null);\r\n  const [audioSource, setAudioSource] = useState<MediaElementAudioSourceNode | null>(null);\r\n  const animationFrameRef = useRef<number | null>(null);\r\n\r\n  /**\r\n   * Safely close an AudioContext\r\n   */\r\n  const safelyCloseAudioContext = useCallback((context: AudioContext | null) => {\r\n    if (!context) return Promise.resolve();\r\n    \r\n    try {\r\n      if (context.state === 'closed') {\r\n        console.log('Context already closed, no action needed');\r\n        return Promise.resolve();\r\n      }\r\n      \r\n      console.log('Safely closing audio context...');\r\n      return context.close().catch(err => {\r\n        console.error('Error during safe context close:', err);\r\n      });\r\n    } catch (error) {\r\n      console.error('Exception during safe context close:', error);\r\n      return Promise.resolve();\r\n    }\r\n  }, []);\r\n  \r\n  /**\r\n   * Reset and clean up audio context and related resources\r\n   */\r\n  const resetAudioContext = useCallback(() => {\r\n    console.log('Resetting audio context...');\r\n    \r\n    // Clean up existing audio processing chain\r\n    if (audioSource) {\r\n      try {\r\n        audioSource.disconnect();\r\n      } catch (e) {\r\n        console.error('Error disconnecting audio source', e);\r\n      }\r\n      setAudioSource(null);\r\n    }\r\n    \r\n    if (analyser) {\r\n      try {\r\n        analyser.disconnect();\r\n      } catch (e) {\r\n        console.error('Error disconnecting analyser', e);\r\n      }\r\n      setAnalyser(null);\r\n    }\r\n    \r\n    if (audioContext) {\r\n      try {\r\n        // Check if the AudioContext is not already closed before trying to close it\r\n        if (audioContext.state !== 'closed') {\r\n          console.log('Closing AudioContext, current state:', audioContext.state);\r\n          audioContext.close().catch(err => {\r\n            console.error('Error closing audio context:', err);\r\n          });\r\n        } else {\r\n          console.log('AudioContext already closed, skipping close operation');\r\n        }\r\n      } catch (e) {\r\n        console.error('Error with audio context:', e);\r\n      }\r\n      setAudioContext(null);\r\n    }\r\n    \r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n      animationFrameRef.current = null;\r\n    }\r\n  }, [audioContext, audioSource, analyser]);\r\n\r\n  /**\r\n   * Modified reset function that uses the safe close helper\r\n   */\r\n  const safeResetAudioContext = useCallback(() => {\r\n    console.log('Safely resetting audio context...');\r\n    \r\n    // Clean up existing audio processing chain\r\n    if (audioSource) {\r\n      try {\r\n        audioSource.disconnect();\r\n      } catch (e) {\r\n        console.error('Error disconnecting audio source', e);\r\n      }\r\n      setAudioSource(null);\r\n    }\r\n    \r\n    if (analyser) {\r\n      try {\r\n        analyser.disconnect();\r\n      } catch (e) {\r\n        console.error('Error disconnecting analyser', e);\r\n      }\r\n      setAnalyser(null);\r\n    }\r\n    \r\n    // Use the safe close helper\r\n    if (audioContext) {\r\n      safelyCloseAudioContext(audioContext)\r\n        .then(() => {\r\n          setAudioContext(null);\r\n          console.log('Audio context safely closed and reset');\r\n        });\r\n    }\r\n    \r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n      animationFrameRef.current = null;\r\n    }\r\n  }, [audioContext, audioSource, analyser, safelyCloseAudioContext]);\r\n\r\n  /**\r\n   * Create a new audio context and analyzer\r\n   */\r\n  const createAudioContext = useCallback((url?: string) => {\r\n    console.log('Creating new audio context...');\r\n    \r\n    // First safely reset any existing context\r\n    if (audioContext || audioSource || analyser) {\r\n      safeResetAudioContext();\r\n      \r\n      // Wait a small amount of time to ensure context is properly reset\r\n      // This helps prevent errors when creating a new context immediately after closing an old one\r\n      return new Promise<boolean>(resolve => {\r\n        setTimeout(() => {\r\n          createNewContext(url).then(resolve);\r\n        }, 100);\r\n      });\r\n    } else {\r\n      return createNewContext(url);\r\n    }\r\n    \r\n    // Helper function to create a new context\r\n    async function createNewContext(sourceUrl?: string): Promise<boolean> {\r\n      try {\r\n        const AudioContext = window.AudioContext || (window as any).webkitAudioContext;\r\n        if (!AudioContext) {\r\n          console.error('AudioContext not supported in this browser');\r\n          return false;\r\n        }\r\n        \r\n        const audio = audioRef.current;\r\n        if (!audio) {\r\n          console.error('Audio element not found');\r\n          return false;\r\n        }\r\n        \r\n        // Check if audio has a valid source\r\n        if (!audio.src || audio.src === 'about:blank') {\r\n          console.warn('Audio element has no source, checking URL...');\r\n          \r\n          if (sourceUrl) {\r\n            console.log('Setting audio source from URL before creating context');\r\n            audio.src = sourceUrl;\r\n            audio.load();\r\n          } else {\r\n            console.error('No URL available for audio source');\r\n            return false;\r\n          }\r\n        }\r\n        \r\n        // Create new context\r\n        const newAudioContext = new AudioContext();\r\n        console.log('New AudioContext created, state:', newAudioContext.state);\r\n        \r\n        // Create new analyzer\r\n        const newAnalyser = newAudioContext.createAnalyser();\r\n        newAnalyser.fftSize = 256;\r\n        newAnalyser.smoothingTimeConstant = 0.7;\r\n        \r\n        // Connect audio element to the analyser\r\n        let source;\r\n        try {\r\n          source = newAudioContext.createMediaElementSource(audio);\r\n        } catch (err) {\r\n          // Type cast the unknown error to access its properties\r\n          const error = err as { message?: string };\r\n          \r\n          // Handle the case where the audio element is already connected\r\n          if (error?.message && error.message.includes('already connected')) {\r\n            console.warn('Audio element already connected, trying alternative approach...');\r\n            \r\n            // First safely close any existing context\r\n            if (audioContext) {\r\n              await safelyCloseAudioContext(audioContext);\r\n              setAudioContext(null);\r\n            }\r\n            \r\n            // Create a fresh audio element to work with\r\n            try {\r\n              // Temporarily disconnect the audio element\r\n              audio.pause();\r\n              \r\n              // Create a new audio context and try again with a small delay\r\n              const retryContext = new AudioContext();\r\n              const retryAnalyser = retryContext.createAnalyser();\r\n              retryAnalyser.fftSize = 256;\r\n              retryAnalyser.smoothingTimeConstant = 0.7;\r\n              \r\n              // Try with the existing audio element\r\n              source = retryContext.createMediaElementSource(audio);\r\n              source.connect(retryAnalyser);\r\n              retryAnalyser.connect(retryContext.destination);\r\n              \r\n              // Update state with new components\r\n              setAudioContext(retryContext);\r\n              setAnalyser(retryAnalyser);\r\n              setAudioSource(source);\r\n              \r\n              console.log('Successfully created audio context on retry');\r\n              return true;\r\n            } catch (retryError) {\r\n              console.error('Failed on retry to create audio context:', retryError);\r\n              return false;\r\n            }\r\n          } else {\r\n            console.error('Failed to create media element source:', error);\r\n            return false;\r\n          }\r\n        }\r\n        \r\n        source.connect(newAnalyser);\r\n        newAnalyser.connect(newAudioContext.destination);\r\n        \r\n        // Update state with new components\r\n        setAudioContext(newAudioContext);\r\n        setAnalyser(newAnalyser);\r\n        setAudioSource(source);\r\n        \r\n        // Resume context if needed\r\n        if (newAudioContext.state === 'suspended') {\r\n          try {\r\n            await newAudioContext.resume();\r\n            console.log('AudioContext resumed successfully');\r\n          } catch (err) {\r\n            console.error('Failed to resume AudioContext:', err);\r\n          }\r\n        }\r\n        \r\n        console.log('Audio context created and initialized successfully');\r\n        return true;\r\n      } catch (err) {\r\n        console.error('Failed to create audio context:', err);\r\n        return false;\r\n      }\r\n    }\r\n  }, [audioRef, audioContext, audioSource, analyser, safeResetAudioContext, safelyCloseAudioContext]);\r\n\r\n  return {\r\n    audioContext,\r\n    analyser,\r\n    audioSource,\r\n    animationFrameRef,\r\n    resetAudioContext,\r\n    safeResetAudioContext,\r\n    safelyCloseAudioContext,\r\n    createAudioContext,\r\n    setAudioContext,\r\n    setAnalyser,\r\n    setAudioSource\r\n  };\r\n};\r\n\r\nexport default useAudioContext; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}