{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\n/**\r\n * Custom hook to control audio playback\r\n */\nexport const useAudioPlayer = ({\n  audioRef,\n  url,\n  onEnd,\n  volume = 0.8,\n  createAudioContext,\n  audioContext,\n  safeResetAudioContext\n}) => {\n  _s();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Utility function for better URL handling\n  const sanitizeUrl = useCallback(url => {\n    if (!url) {\n      console.error('Empty URL provided to sanitizeUrl');\n      return '';\n    }\n    console.log('Sanitizing URL:', url);\n\n    // If it's already an HTTP URL, return it as is\n    if (url.startsWith('http')) {\n      return url;\n    }\n\n    // If it's already a server API path, return it as is\n    if (url.startsWith('/api/')) {\n      return url;\n    }\n\n    // If it's a Windows path, ensure it's properly formatted\n    // Replace backslashes with forward slashes for the URL\n    let formattedPath = url.replace(/\\\\/g, '/');\n\n    // Make sure the path is properly encoded for URLs\n    formattedPath = encodeURIComponent(formattedPath);\n\n    // Return the full API URL\n    const finalUrl = `/api/audio?path=${formattedPath}`;\n    console.log('Sanitized URL:', finalUrl);\n    return finalUrl;\n  }, []);\n\n  // Update the URL handling effect for better playback\n  useEffect(() => {\n    if (!url) {\n      console.log('No URL provided');\n      return;\n    }\n    let isMounted = true;\n    setLoading(true);\n    setError(null);\n    console.log('Loading track URL:', url);\n\n    // Reset audio context to ensure clean playback for the new track\n    safeResetAudioContext();\n\n    // Create a new Audio element instead of reusing\n    const audio = audioRef.current;\n    if (!audio) {\n      console.error('Audio element not found');\n      if (isMounted) setError('Audio player initialization failed');\n      return;\n    }\n\n    // Properly clean up previous audio\n    try {\n      audio.pause();\n      audio.src = '';\n      audio.removeAttribute('src');\n      audio.load();\n    } catch (err) {\n      console.error('Error cleaning up previous audio:', err);\n    }\n\n    // Function to handle successful load\n    const handleSuccess = () => {\n      if (!isMounted) return;\n      setLoading(false);\n      setIsPlaying(true);\n      console.log('Track loaded successfully');\n    };\n\n    // Function to handle errors\n    const handleFailure = err => {\n      if (!isMounted) return;\n      console.error('Error playing track:', err);\n      setLoading(false);\n      setIsPlaying(false);\n      let errorMessage = 'Unknown error';\n      if (err instanceof Error) {\n        errorMessage = err.message;\n      } else if (typeof err === 'string') {\n        errorMessage = err;\n      } else if (err && typeof err === 'object') {\n        errorMessage = String(err);\n      }\n      setError(`Error loading audio: ${errorMessage}`);\n    };\n\n    // Small delay to ensure proper cleanup\n    setTimeout(() => {\n      if (!isMounted) return;\n      try {\n        // Set new audio source\n        const sanitizedUrl = sanitizeUrl(url);\n        console.log('Setting audio source to:', sanitizedUrl);\n\n        // Check if URL is valid\n        if (!sanitizedUrl) {\n          handleFailure('Invalid audio URL');\n          return;\n        }\n        audio.src = sanitizedUrl;\n        audio.volume = volume;\n        audio.crossOrigin = 'anonymous'; // Ensure this is set for remote resources\n        audio.load();\n\n        // Try to play automatically\n        console.log('Attempting to play audio');\n        const playPromise = audio.play();\n        if (playPromise !== undefined) {\n          playPromise.then(handleSuccess).catch(err => {\n            console.error('Play failed, retrying once:', err);\n\n            // Some browsers require user interaction - if play fails, we'll try once more after a short delay\n            setTimeout(() => {\n              if (!audio || !isMounted) return;\n              const retryPlay = audio.play();\n              if (retryPlay !== undefined) {\n                retryPlay.then(handleSuccess).catch(handleFailure);\n              }\n            }, 300);\n          });\n        } else {\n          // For older browsers that don't return a promise\n          handleSuccess();\n        }\n      } catch (err) {\n        handleFailure(err);\n      }\n    }, 200); // Slightly longer delay\n\n    return () => {\n      isMounted = false;\n      // Don't stop playback on cleanup, let the new track take over\n    };\n  }, [url, volume, safeResetAudioContext, audioRef, sanitizeUrl]);\n\n  // Handle time update\n  const handleTimeUpdate = useCallback(() => {\n    if (audioRef.current) {\n      setCurrentTime(audioRef.current.currentTime);\n    }\n  }, [audioRef]);\n\n  // Handle loaded metadata\n  const handleLoadedMetadata = useCallback(() => {\n    if (audioRef.current) {\n      setDuration(audioRef.current.duration);\n      setLoading(false);\n\n      // If the audio element has autoplay set\n      if (audioRef.current.autoplay) {\n        const playPromise = audioRef.current.play();\n        if (playPromise !== undefined) {\n          playPromise.then(() => {\n            setIsPlaying(true);\n            console.log('Auto-play successful after metadata loaded');\n          }).catch(error => {\n            console.error('Error auto-playing after metadata loaded:', error);\n          });\n        }\n      }\n    }\n  }, [audioRef]);\n\n  // Handle track ended\n  const handleEnded = useCallback(() => {\n    setIsPlaying(false);\n    setCurrentTime(0);\n    if (audioRef.current) {\n      audioRef.current.currentTime = 0;\n    }\n    if (onEnd) {\n      onEnd();\n    }\n  }, [audioRef, onEnd]);\n\n  // Handle errors\n  const handleError = useCallback(() => {\n    console.error('Audio error');\n    setError('Error loading audio. Please try again or select another track.');\n    setLoading(false);\n    setIsPlaying(false);\n  }, []);\n\n  // Add event listeners with cleanup\n  useEffect(() => {\n    const audio = audioRef.current;\n    if (!audio) return;\n    audio.addEventListener('timeupdate', handleTimeUpdate);\n    audio.addEventListener('loadedmetadata', handleLoadedMetadata);\n    audio.addEventListener('ended', handleEnded);\n    audio.addEventListener('error', handleError);\n    return () => {\n      audio.removeEventListener('timeupdate', handleTimeUpdate);\n      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      audio.removeEventListener('ended', handleEnded);\n      audio.removeEventListener('error', handleError);\n    };\n  }, [handleTimeUpdate, handleLoadedMetadata, handleEnded, handleError, audioRef]);\n\n  // Handle Play/Pause\n  const handlePlayPause = useCallback(() => {\n    if (!audioRef.current) return;\n    if (isPlaying) {\n      audioRef.current.pause();\n      setIsPlaying(false);\n    } else {\n      console.log('Trying to play audio...');\n\n      // Reset audio context if needed to ensure fresh playback\n      if (createAudioContext && (!audioContext || audioContext.state === 'closed')) {\n        console.log('Audio context not available or closed, reinitializing...');\n        createAudioContext(url);\n      }\n      try {\n        // Make sure we have a source\n        if (!audioRef.current.src || audioRef.current.src === 'about:blank') {\n          if (url) {\n            const sanitizedUrl = sanitizeUrl(url);\n            audioRef.current.src = sanitizedUrl;\n            audioRef.current.load();\n          } else {\n            setError('No audio source available');\n            return;\n          }\n        }\n        const playPromise = audioRef.current.play();\n        if (playPromise !== undefined) {\n          playPromise.then(() => {\n            console.log('Playback started successfully');\n            setIsPlaying(true);\n            setError(null);\n          }).catch(error => {\n            console.error('Playback error:', error);\n            setError('Playback error. Please try again.');\n            setIsPlaying(false);\n          });\n        }\n      } catch (error) {\n        console.error('Exception during play attempt:', error);\n        setError('Error starting playback');\n      }\n    }\n  }, [isPlaying, audioContext, createAudioContext, url, audioRef, sanitizeUrl]);\n\n  // Handle seeking\n  const handleSeek = useCallback(seekTime => {\n    setCurrentTime(seekTime);\n    if (audioRef.current) {\n      audioRef.current.currentTime = seekTime;\n    }\n  }, [audioRef]);\n\n  // Handle volume change\n  const handleVolumeChange = useCallback(newVolume => {\n    if (audioRef.current) {\n      audioRef.current.volume = newVolume;\n    }\n  }, [audioRef]);\n  return {\n    isPlaying,\n    currentTime,\n    duration,\n    loading,\n    error,\n    handlePlayPause,\n    handleSeek,\n    handleVolumeChange,\n    sanitizeUrl\n  };\n};\n_s(useAudioPlayer, \"/3wtiYFImZm/wz9P1ZSTFcGU4Ro=\");\nexport default useAudioPlayer;","map":{"version":3,"names":["useState","useCallback","useEffect","useAudioPlayer","audioRef","url","onEnd","volume","createAudioContext","audioContext","safeResetAudioContext","_s","isPlaying","setIsPlaying","currentTime","setCurrentTime","duration","setDuration","loading","setLoading","error","setError","sanitizeUrl","console","log","startsWith","formattedPath","replace","encodeURIComponent","finalUrl","isMounted","audio","current","pause","src","removeAttribute","load","err","handleSuccess","handleFailure","errorMessage","Error","message","String","setTimeout","sanitizedUrl","crossOrigin","playPromise","play","undefined","then","catch","retryPlay","handleTimeUpdate","handleLoadedMetadata","autoplay","handleEnded","handleError","addEventListener","removeEventListener","handlePlayPause","state","handleSeek","seekTime","handleVolumeChange","newVolume"],"sources":["C:/Users/rohit/spotify/spotify_downloads/client/src/components/audio-player/hooks/useAudioPlayer.ts"],"sourcesContent":["import { useState, useCallback, useEffect, RefObject } from 'react';\r\n\r\ninterface UseAudioPlayerProps {\r\n  audioRef: RefObject<HTMLAudioElement>;\r\n  url: string;\r\n  onEnd?: () => void;\r\n  volume?: number;\r\n  createAudioContext?: (url?: string) => Promise<boolean> | boolean;\r\n  audioContext: AudioContext | null;\r\n  safeResetAudioContext: () => void;\r\n}\r\n\r\n/**\r\n * Custom hook to control audio playback\r\n */\r\nexport const useAudioPlayer = ({\r\n  audioRef,\r\n  url,\r\n  onEnd,\r\n  volume = 0.8,\r\n  createAudioContext,\r\n  audioContext,\r\n  safeResetAudioContext\r\n}: UseAudioPlayerProps) => {\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [duration, setDuration] = useState(0);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // Utility function for better URL handling\r\n  const sanitizeUrl = useCallback((url: string) => {\r\n    if (!url) {\r\n      console.error('Empty URL provided to sanitizeUrl');\r\n      return '';\r\n    }\r\n    \r\n    console.log('Sanitizing URL:', url);\r\n    \r\n    // If it's already an HTTP URL, return it as is\r\n    if (url.startsWith('http')) {\r\n      return url;\r\n    }\r\n    \r\n    // If it's already a server API path, return it as is\r\n    if (url.startsWith('/api/')) {\r\n      return url;\r\n    }\r\n    \r\n    // If it's a Windows path, ensure it's properly formatted\r\n    // Replace backslashes with forward slashes for the URL\r\n    let formattedPath = url.replace(/\\\\/g, '/');\r\n    \r\n    // Make sure the path is properly encoded for URLs\r\n    formattedPath = encodeURIComponent(formattedPath);\r\n    \r\n    // Return the full API URL\r\n    const finalUrl = `/api/audio?path=${formattedPath}`;\r\n    console.log('Sanitized URL:', finalUrl);\r\n    return finalUrl;\r\n  }, []);\r\n\r\n  // Update the URL handling effect for better playback\r\n  useEffect(() => {\r\n    if (!url) {\r\n      console.log('No URL provided');\r\n      return;\r\n    }\r\n    \r\n    let isMounted = true;\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    console.log('Loading track URL:', url);\r\n    \r\n    // Reset audio context to ensure clean playback for the new track\r\n    safeResetAudioContext();\r\n    \r\n    // Create a new Audio element instead of reusing\r\n    const audio = audioRef.current;\r\n    if (!audio) {\r\n      console.error('Audio element not found');\r\n      if (isMounted) setError('Audio player initialization failed');\r\n      return;\r\n    }\r\n    \r\n    // Properly clean up previous audio\r\n    try {\r\n      audio.pause();\r\n      audio.src = '';\r\n      audio.removeAttribute('src');\r\n      audio.load();\r\n    } catch (err) {\r\n      console.error('Error cleaning up previous audio:', err);\r\n    }\r\n    \r\n    // Function to handle successful load\r\n    const handleSuccess = () => {\r\n      if (!isMounted) return;\r\n      \r\n      setLoading(false);\r\n      setIsPlaying(true);\r\n      console.log('Track loaded successfully');\r\n    };\r\n    \r\n    // Function to handle errors\r\n    const handleFailure = (err: any) => {\r\n      if (!isMounted) return;\r\n      \r\n      console.error('Error playing track:', err);\r\n      setLoading(false);\r\n      setIsPlaying(false);\r\n      let errorMessage = 'Unknown error';\r\n      if (err instanceof Error) {\r\n        errorMessage = err.message;\r\n      } else if (typeof err === 'string') {\r\n        errorMessage = err;\r\n      } else if (err && typeof err === 'object') {\r\n        errorMessage = String(err);\r\n      }\r\n      \r\n      setError(`Error loading audio: ${errorMessage}`);\r\n    };\r\n    \r\n    // Small delay to ensure proper cleanup\r\n    setTimeout(() => {\r\n      if (!isMounted) return;\r\n      \r\n      try {\r\n        // Set new audio source\r\n        const sanitizedUrl = sanitizeUrl(url);\r\n        console.log('Setting audio source to:', sanitizedUrl);\r\n        \r\n        // Check if URL is valid\r\n        if (!sanitizedUrl) {\r\n          handleFailure('Invalid audio URL');\r\n          return;\r\n        }\r\n        \r\n        audio.src = sanitizedUrl;\r\n        audio.volume = volume;\r\n        audio.crossOrigin = 'anonymous'; // Ensure this is set for remote resources\r\n        audio.load();\r\n        \r\n        // Try to play automatically\r\n        console.log('Attempting to play audio');\r\n        const playPromise = audio.play();\r\n        if (playPromise !== undefined) {\r\n          playPromise\r\n            .then(handleSuccess)\r\n            .catch((err) => {\r\n              console.error('Play failed, retrying once:', err);\r\n              \r\n              // Some browsers require user interaction - if play fails, we'll try once more after a short delay\r\n              setTimeout(() => {\r\n                if (!audio || !isMounted) return;\r\n                \r\n                const retryPlay = audio.play();\r\n                if (retryPlay !== undefined) {\r\n                  retryPlay.then(handleSuccess).catch(handleFailure);\r\n                }\r\n              }, 300);\r\n            });\r\n        } else {\r\n          // For older browsers that don't return a promise\r\n          handleSuccess();\r\n        }\r\n      } catch (err) {\r\n        handleFailure(err);\r\n      }\r\n    }, 200); // Slightly longer delay\r\n    \r\n    return () => {\r\n      isMounted = false;\r\n      // Don't stop playback on cleanup, let the new track take over\r\n    };\r\n  }, [url, volume, safeResetAudioContext, audioRef, sanitizeUrl]);\r\n\r\n  // Handle time update\r\n  const handleTimeUpdate = useCallback(() => {\r\n    if (audioRef.current) {\r\n      setCurrentTime(audioRef.current.currentTime);\r\n    }\r\n  }, [audioRef]);\r\n\r\n  // Handle loaded metadata\r\n  const handleLoadedMetadata = useCallback(() => {\r\n    if (audioRef.current) {\r\n      setDuration(audioRef.current.duration);\r\n      setLoading(false);\r\n      \r\n      // If the audio element has autoplay set\r\n      if (audioRef.current.autoplay) {\r\n        const playPromise = audioRef.current.play();\r\n        if (playPromise !== undefined) {\r\n          playPromise\r\n            .then(() => {\r\n              setIsPlaying(true);\r\n              console.log('Auto-play successful after metadata loaded');\r\n            })\r\n            .catch(error => {\r\n              console.error('Error auto-playing after metadata loaded:', error);\r\n            });\r\n        }\r\n      }\r\n    }\r\n  }, [audioRef]);\r\n\r\n  // Handle track ended\r\n  const handleEnded = useCallback(() => {\r\n    setIsPlaying(false);\r\n    setCurrentTime(0);\r\n    \r\n    if (audioRef.current) {\r\n      audioRef.current.currentTime = 0;\r\n    }\r\n    \r\n    if (onEnd) {\r\n      onEnd();\r\n    }\r\n  }, [audioRef, onEnd]);\r\n\r\n  // Handle errors\r\n  const handleError = useCallback(() => {\r\n    console.error('Audio error');\r\n    setError('Error loading audio. Please try again or select another track.');\r\n    setLoading(false);\r\n    setIsPlaying(false);\r\n  }, []);\r\n\r\n  // Add event listeners with cleanup\r\n  useEffect(() => {\r\n    const audio = audioRef.current;\r\n    if (!audio) return;\r\n    \r\n    audio.addEventListener('timeupdate', handleTimeUpdate);\r\n    audio.addEventListener('loadedmetadata', handleLoadedMetadata);\r\n    audio.addEventListener('ended', handleEnded);\r\n    audio.addEventListener('error', handleError);\r\n    \r\n    return () => {\r\n      audio.removeEventListener('timeupdate', handleTimeUpdate);\r\n      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\r\n      audio.removeEventListener('ended', handleEnded);\r\n      audio.removeEventListener('error', handleError);\r\n    };\r\n  }, [handleTimeUpdate, handleLoadedMetadata, handleEnded, handleError, audioRef]);\r\n\r\n  // Handle Play/Pause\r\n  const handlePlayPause = useCallback(() => {\r\n    if (!audioRef.current) return;\r\n    \r\n    if (isPlaying) {\r\n      audioRef.current.pause();\r\n      setIsPlaying(false);\r\n    } else {\r\n      console.log('Trying to play audio...');\r\n      \r\n      // Reset audio context if needed to ensure fresh playback\r\n      if (createAudioContext && (!audioContext || audioContext.state === 'closed')) {\r\n        console.log('Audio context not available or closed, reinitializing...');\r\n        createAudioContext(url);\r\n      }\r\n      \r\n      try {\r\n        // Make sure we have a source\r\n        if (!audioRef.current.src || audioRef.current.src === 'about:blank') {\r\n          if (url) {\r\n            const sanitizedUrl = sanitizeUrl(url);\r\n            audioRef.current.src = sanitizedUrl;\r\n            audioRef.current.load();\r\n          } else {\r\n            setError('No audio source available');\r\n            return;\r\n          }\r\n        }\r\n        \r\n        const playPromise = audioRef.current.play();\r\n        if (playPromise !== undefined) {\r\n          playPromise\r\n            .then(() => {\r\n              console.log('Playback started successfully');\r\n              setIsPlaying(true);\r\n              setError(null);\r\n            })\r\n            .catch(error => {\r\n              console.error('Playback error:', error);\r\n              setError('Playback error. Please try again.');\r\n              setIsPlaying(false);\r\n            });\r\n        }\r\n      } catch (error) {\r\n        console.error('Exception during play attempt:', error);\r\n        setError('Error starting playback');\r\n      }\r\n    }\r\n  }, [isPlaying, audioContext, createAudioContext, url, audioRef, sanitizeUrl]);\r\n\r\n  // Handle seeking\r\n  const handleSeek = useCallback((seekTime: number) => {\r\n    setCurrentTime(seekTime);\r\n    if (audioRef.current) {\r\n      audioRef.current.currentTime = seekTime;\r\n    }\r\n  }, [audioRef]);\r\n\r\n  // Handle volume change\r\n  const handleVolumeChange = useCallback((newVolume: number) => {\r\n    if (audioRef.current) {\r\n      audioRef.current.volume = newVolume;\r\n    }\r\n  }, [audioRef]);\r\n\r\n  return {\r\n    isPlaying,\r\n    currentTime,\r\n    duration,\r\n    loading,\r\n    error,\r\n    handlePlayPause,\r\n    handleSeek,\r\n    handleVolumeChange,\r\n    sanitizeUrl\r\n  };\r\n};\r\n\r\nexport default useAudioPlayer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}